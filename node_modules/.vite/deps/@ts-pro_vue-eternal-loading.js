import {
  createBaseVNode,
  createCommentVNode,
  createElementBlock,
  defineComponent,
  mergeProps,
  nextTick,
  normalizeProps,
  openBlock,
  ref,
  renderSlot,
  unref,
  watch,
  watchEffect
} from "./chunk-QO6ZHO7P.js";
import "./chunk-TWLJ45QX.js";

// node_modules/@ts-pro/vue-eternal-loading/dist/vue-eternal-loading.mjs
function T(o) {
  return o.scrollHeight;
}
function W(o) {
  return o.scrollWidth;
}
function z(o, s) {
  o.scrollTop = o.scrollHeight - s + o.scrollTop;
}
function C(o, s) {
  o.scrollLeft = o.scrollWidth - s + o.scrollLeft;
}
var M = createBaseVNode("div", { class: "loading" }, "Loading...", -1);
var j = createBaseVNode("div", { class: "no-more" }, "No more.", -1);
var D = createBaseVNode("div", { class: "no-results" }, "No results.", -1);
var A = createBaseVNode("div", { class: "error" }, "Error.", -1);
var J = defineComponent({
  __name: "VueEternalLoading",
  props: {
    load: {
      required: true,
      type: Function
    },
    isInitial: {
      required: false,
      type: Boolean,
      default: true
    },
    position: {
      required: false,
      type: String,
      default: "default"
    },
    container: {
      required: false,
      type: Object,
      default: null
    },
    margin: {
      required: false,
      type: String,
      default: void 0
    }
  },
  emits: ["update:isInitial"],
  setup(o, { emit: s }) {
    const t = o, l = ref();
    let a = ref("loading"), r = ref(t.isInitial);
    const F = typeof process < "u" && process.env !== void 0 && true;
    let c = 0;
    function d() {
      nextTick(() => {
        var e, n;
        t.position === "top" ? z(
          (e = t.container) != null ? e : document.documentElement,
          c
        ) : t.position === "left" && C(
          (n = t.container) != null ? n : document.documentElement,
          c
        );
      });
    }
    function N(e, n) {
      return e === 0 ? r.value ? (S(), "no-results") : (y(), "no-more") : e !== void 0 && n !== void 0 && e < n ? (y(), "no-more") : (r.value = false, d(), f(), "loading");
    }
    function y() {
      r.value = false, u("no-more"), d();
    }
    function S() {
      r.value = false, u("no-results"), d();
    }
    function V() {
      r.value = false, u("error"), d();
    }
    function q() {
      r.value = true, u("loading"), f();
    }
    function E() {
      u("loading"), f();
    }
    function u(e) {
      a.value = e;
    }
    function b() {
      l.value && m.unobserve(l.value);
    }
    function f() {
      l.value && m.observe(l.value);
    }
    function O() {
      return new IntersectionObserver(
        ([e]) => {
          var n, k;
          e.isIntersecting && (t.position === "top" ? c = T(
            (n = t.container) != null ? n : document.documentElement
          ) : t.position === "left" && (c = W(
            (k = t.container) != null ? k : document.documentElement
          )), b(), t.load(
            {
              loaded: N,
              noMore: y,
              noResults: S,
              error: V
            },
            {
              isFirstLoad: r.value
            }
          ));
        },
        {
          root: t.container,
          threshold: 0,
          rootMargin: t.margin
        }
      );
    }
    let m;
    return typeof IntersectionObserver < "u" && watchEffect(
      () => {
        m && b(), m = O(), f();
      },
      {
        flush: "post"
      }
    ), watch(
      () => t.isInitial,
      (e) => {
        e && q();
      }
    ), watch(r, (e) => {
      e || s("update:isInitial", false);
    }), (e, n) => unref(F) ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", {
      key: 0,
      class: "vue-eternal-loading",
      ref_key: "rootRef",
      ref: l
    }, [
      unref(a) === "loading" ? renderSlot(e.$slots, "loading", normalizeProps(mergeProps({ key: 0 }, { isFirstLoad: unref(r) })), () => [
        M
      ]) : unref(a) === "no-more" ? renderSlot(e.$slots, "no-more", normalizeProps(mergeProps({ key: 1 }, { retry: E })), () => [
        j
      ]) : unref(a) === "no-results" ? renderSlot(e.$slots, "no-results", normalizeProps(mergeProps({ key: 2 }, { retry: E })), () => [
        D
      ]) : unref(a) === "error" ? renderSlot(e.$slots, "error", normalizeProps(mergeProps({ key: 3 }, { retry: E })), () => [
        A
      ]) : createCommentVNode("", true)
    ], 512));
  }
});
export {
  J as VueEternalLoading
};
//# sourceMappingURL=@ts-pro_vue-eternal-loading.js.map
